## HH DZ
1) **Представим, что у нас есть данные, которые мы очень часто читаем по сравнению с другими (например, словарь стран). Как можно это оптимизировать?**

    Если необходимо читать именно такой (маленький) объем данных, то можно хранить их в оперативной
    памяти самого сервиса. Также можно попробовать сохранять такой запрос в кэш браузера клиента.
    
    Использовать технологии связанные с хранением данных в памяти.
    Redis прекрасно подходит для организации высокодоступного кэша в памяти, 
    который уменьшает задержку доступа, увеличивает пропускную способность и 
    снижает нагрузку на реляционную базу данных или базу данных NoSQL и на приложение. 
    Redis может обеспечить доступ к часто запрашиваемым данным с задержкой в доли миллисекунды.

    **Плюсы:**<br/>
    Скорость обработки запросов;<br/>
    Можно использовать несколькии сервисами;<br/>

    **Минусы:**<br/>
    Значения не могут превышать 512 МБ;<br/>
    Отсутствует механизм очистки данных;<br/>
    Издержки на tcp соединение;<br/>
    Проблема инвалидации кэша;<br/>
    Потеря данных в кэше при падении Redis.<br/>
    
    Если есть деньги можно попробовать применить CDN.

2) **Что можно сделать, если таблица вакансий стала слишком большой? Какие есть решения на уровне текущей базы данных? Можно ли ее чем-то заменить?**<br/>

    -> Создать дополнительные индексы для поиска;<br/>
        **Плюсы:**<br/>
        Будет выигрыш в скорости при чтении данных;<br/>
        **Минусы:**<br/>
        Индексы займут дополнительное место на диске;<br/>
        Можем просесть при добавлении записей в таблицу.<br/>

    -> Секционировать таблицу на таблички поменьше;<br/>
        **Плюсы:**<br/>
        В определённых ситуациях оно кардинально увеличивает быстродействие, особенно когда большой процент часто запрашиваемых строк таблицы относится к одной или лишь нескольким секциям. Секционирование может сыграть роль ведущих столбцов в индексах, что позволит уменьшить размер индекса и увеличит вероятность нахождения наиболее востребованных частей индексов в памяти;<br/>
        Когда в выборке или изменении данных задействована большая часть одной секции, последовательное сканирование этой секции может выполняться гораздо быстрее;<br/>
        Массовую загрузку и удаление данных можно осуществлять, добавляя и удаляя секции;<br/>
        Редко используемые данные можно перенести на более дешёвые и медленные носители;<br/>
        **Минусы:**<br/>
        Трудность реализации и поддержки.<br/>

    -> Применить масштабирование:<br/>
        Вертикальное — добавление в сервер памяти и дисков.<br/>
        Горизонтальное — распределение данных между несколькими машинами (Шардирование).<br/>
        **Плюсы:**<br/>
        Прирост производительности;<br/>
        **Минусы:**<br/>
        Ограниченность ресурсов и денежных средств.<br/>

    -> Попробовать воспользоваться какими-то NoSQL решениями.<br/>
        **Плюсы:**<br/>
        Прирост производительности;<br/>
        **Минусы:**<br/>
        Усложнение системы из-за добавления новых узлов и необходимости их контролирования.<br/>

3) **Какие вы видите узкие места, возможно неправильно выбранные технологии в текущей схеме (можно рассмотреть как "нашу" схему, так и схему настоящего hh.ru) ?**
    
    ![our-arch-hh-ru.png](our-arch-hh-ru.png)
    
    В предложенной нами архитектуре совсем отсутствуют кэши, поэтому необходимо их добавить около API,
    проблемы связанные с этим описаны в пункте 1. Необходимо продублировать queue для повышения надежности.
    Несовсем понятно как app будет записывать данные в БД через балансер, это технически не возможно.
    А даже если и возможно, то необходимо, чтобы во время транзакции сервиса app работа происходила с одной
    и той же базой, иначе данные будут невалидны.
    
    Можно добавить еще несколько worker'ов для генерации отчетов.
    Это необходимо для повышения отказоустойчивости, поможет быстрее генерировать отчеты, если появятся различные типы отчетов.
    Из минусов можно отметить необходимость в покрытии воркеров для новых типов отчетов тестами и неоходимость выделения ресурсов
    для воркеров.
    
    Необходимо добавить balancer между worker'ами и readonly репликами БД, чтобы worker'ы могли работать с различными репликами,
    а не загружать одну. Из минусов получим увеличение времени ответа.
     
